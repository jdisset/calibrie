# calibrie/gui/diagnostics.py

import dearpygui.dearpygui as dpg
import numpy as np

# Remove the problematic import below:
# from calibrie.gui.diagnostics import DiagnosticsPanel
from calibrie.gui.core import Component, unique_tag  # Keep this one
from calibrie.pipeline import DiagnosticFigure
from typing import List, Optional, Any  # Added Any
import matplotlib

matplotlib.use('Agg')  # Use non-interactive backend for figure generation


class DiagnosticsPanel(Component):
    """Displays diagnostic figures generated by tasks."""

    figures: List[DiagnosticFigure] = []
    _texture_tag: str = ""
    _image_width: int = 1000
    _image_height: int = 1000
    _current_fig_index: int = 0
    _plot_tag: str = ""
    _xaxis_tag: str = ""
    _yaxis_tag: str = ""
    _image_series_tag: str = ""
    _button_prev_tag: str = ""
    _button_next_tag: str = ""
    _fig_label_tag: str = ""

    def model_post_init(self, __context: Any) -> None:
        super().model_post_init(__context)
        self._texture_tag = unique_tag()
        self._plot_tag = unique_tag()
        self._xaxis_tag = unique_tag()
        self._yaxis_tag = unique_tag()
        self._image_series_tag = unique_tag()
        self._button_prev_tag = unique_tag()
        self._button_next_tag = unique_tag()
        self._fig_label_tag = unique_tag()
        self._current_fig_index = 0
        self.figures = []

    def add(self, parent: str | int, **kwargs) -> str | int:
        """Adds the diagnostics panel UI."""
        with dpg.group(parent=parent, tag=self._ui_tag, **kwargs):
            # --- Navigation ---
            with dpg.group(horizontal=True):
                dpg.add_button(
                    label="< Prev",
                    tag=self._button_prev_tag,
                    callback=self._prev_fig,
                    enabled=False,
                )
                dpg.add_button(
                    label="Next >",
                    tag=self._button_next_tag,
                    callback=self._next_fig,
                    enabled=False,
                )
                dpg.add_text("No figures", tag=self._fig_label_tag)

            # --- Texture Registry (Hidden) ---
            with dpg.texture_registry(show=False):
                # Default empty texture
                default_value = np.zeros(
                    self._image_width * self._image_height * 4, dtype=np.float32
                ).tolist()
                dpg.add_dynamic_texture(
                    width=self._image_width,
                    height=self._image_height,
                    default_value=default_value,
                    tag=self._texture_tag,
                )

            # --- Plot Area ---
            with dpg.plot(
                tag=self._plot_tag,
                label="Diagnostics Plot",
                height=-1,  # Fill available space
                width=-1,
                no_menus=True,
                no_mouse_pos=True,
                equal_aspects=True,  # Keep aspect ratio
            ):
                dpg.add_plot_axis(
                    dpg.mvXAxis,
                    label="",
                    tag=self._xaxis_tag,
                    no_gridlines=True,
                    no_tick_marks=True,
                    no_tick_labels=True,
                )
                with dpg.plot_axis(
                    dpg.mvYAxis,
                    label="",
                    tag=self._yaxis_tag,
                    no_gridlines=True,
                    no_tick_marks=True,
                    no_tick_labels=True,
                ):
                    # Add the image series here, linking it to the texture
                    dpg.add_image_series(
                        self._texture_tag,
                        [0, 0],
                        [self._image_width, self._image_height],
                        tag=self._image_series_tag,
                    )

        self.update_view()  # Initial update
        return self._ui_tag

    def set_figures(self, figures: List[DiagnosticFigure]):
        """Sets the list of figures to display."""
        self.figures = figures or []
        self._current_fig_index = 0
        self.update_view()

    def _prev_fig(self):
        if self.figures and self._current_fig_index > 0:
            self._current_fig_index -= 1
            self.update_view()

    def _next_fig(self):
        if self.figures and self._current_fig_index < len(self.figures) - 1:
            self._current_fig_index += 1
            self.update_view()

    def update_view(self):
        """Updates the displayed figure and navigation buttons."""
        if not dpg.does_item_exist(self._ui_tag):
            return  # Don't update if not added yet

        num_figs = len(self.figures)
        has_figures = num_figs > 0

        # Update navigation buttons
        dpg.configure_item(
            self._button_prev_tag, enabled=has_figures and self._current_fig_index > 0
        )
        dpg.configure_item(
            self._button_next_tag, enabled=has_figures and self._current_fig_index < num_figs - 1
        )

        if has_figures:
            current_fig_data = self.figures[self._current_fig_index]
            label_text = f"Figure {self._current_fig_index + 1}/{num_figs}: {current_fig_data.name} (from {current_fig_data.source_task})"
            # Render figure to texture
            self._render_figure(current_fig_data.fig)
        else:
            label_text = "No figures"
            # Set texture to blank
            default_value = np.zeros(
                self._image_width * self._image_height * 4, dtype=np.float32
            ).tolist()
            if dpg.does_item_exist(self._texture_tag):
                dpg.set_value(self._texture_tag, default_value)

        if dpg.does_item_exist(self._fig_label_tag):
            dpg.set_value(self._fig_label_tag, label_text)

        # Fit plot axes after updating image
        if (
            has_figures
            and dpg.does_item_exist(self._xaxis_tag)
            and dpg.does_item_exist(self._yaxis_tag)
        ):
            dpg.fit_axis_data(self._xaxis_tag)
            dpg.fit_axis_data(self._yaxis_tag)

    def _render_figure(self, fig: matplotlib.figure.Figure):
        """Renders a Matplotlib figure to the dynamic texture."""
        if not dpg.does_item_exist(self._texture_tag):
            return

        try:
            # Ensure figure size matches texture dimensions (or resize texture)
            # For simplicity, let's assume the figure is rendered at the texture size for now.
            # A better approach might involve resizing the texture or scaling the figure.
            fig.set_size_inches(self._image_width / fig.dpi, self._image_height / fig.dpi)
            fig.canvas.draw_idle()  # Ensure the figure is drawn

            # Get RGBA buffer
            buf = fig.canvas.buffer_rgba()
            img_array = np.asarray(buf)

            # Ensure it's float32 and normalized [0, 1]
            if img_array.dtype != np.float32:
                img_array = img_array.astype(np.float32) / 255.0

            # Flatten for DPG
            img_flat = img_array.flatten().tolist()

            # Check size match
            expected_len = self._image_width * self._image_height * 4
            if len(img_flat) != expected_len:
                print(
                    f"Warning: Rendered figure size ({len(img_flat)}) does not match texture size ({expected_len}). Image might be distorted."
                )
                # Simple resize/pad (crude):
                if len(img_flat) > expected_len:
                    img_flat = img_flat[:expected_len]
                else:
                    img_flat.extend([0.0] * (expected_len - len(img_flat)))

            dpg.set_value(self._texture_tag, img_flat)

        except Exception as e:
            print(f"Error rendering figure to texture: {e}")
            import traceback

            traceback.print_exc()
            # Set texture to blank on error
            default_value = np.zeros(
                self._image_width * self._image_height * 4, dtype=np.float32
            ).tolist()
            dpg.set_value(self._texture_tag, default_value)

    def delete(self):
        """Cleans up DPG resources."""
        # We need to delete the texture from the registry
        if dpg.does_item_exist(self._texture_tag):
            # Check if it's actually in the registry before attempting deletion
            # There isn't a direct DPG function to check registry membership,
            # so we rely on does_item_exist and handle potential errors.
            try:
                # Textures need to be deleted via the registry they belong to?
                # Or maybe deleting the item is enough if it's dynamic.
                # Let's try deleting the item directly.
                dpg.delete_item(self._texture_tag)
            except Exception as e:
                print(f"Error deleting texture {self._texture_tag}: {e}")
        super().delete()
